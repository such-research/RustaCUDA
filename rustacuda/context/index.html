<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="CUDA context management"><meta name="keywords" content="rust, rustlang, rust-lang, context"><title>rustacuda::context - Rust</title><link rel="stylesheet" type="text/css" href="../../normalize.css"><link rel="stylesheet" type="text/css" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../../ayu.css" disabled ><script id="default-settings" ></script><script src="../../storage.js"></script><script src="../../crates.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"><style type="text/css">#crate-search{background-image:url("../../down-arrow.svg");}</style></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../../rustacuda/index.html'><div class='logo-container rust-logo'><img src='../../rust-logo.png' alt='logo'></div></a><h2 class="location">Module context</h2><div class="sidebar-elems"><div class="block items"><ul><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li></ul></div><div id="sidebar-vars" data-name="context" data-ty="mod" data-relpath="./"></div><script defer src="./sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../../wheel.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Module <a href="../index.html">rustacuda</a>::<wbr><a class="mod" href="#">context</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../../src/rustacuda/context.rs.html#1-905" title="goto source code">[src]</a></span></h1><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h1 id="cuda-context-management" class="section-header"><a href="#cuda-context-management">CUDA context management</a></h1>
<p>Most CUDA functions require a context. A CUDA context is analogous to a CPU process — it’s
an isolated container for all runtime state, including configuration settings and the
device/unified/page-locked memory allocations. Each context has a separate memory space, and
pointers from one context do not work in another. Each context is associated with a single
device. Although it is possible to have multiple contexts associated with a single device, this
is strongly discouraged as it can cause a significant loss of performance.</p>
<p>CUDA keeps a thread-local stack of contexts which the programmer can push to or pop from.
The top context in that stack is known as the “current” context and it is used in most CUDA
API calls. One context can be safely made current in multiple CPU threads.</p>
<h1 id="safety" class="section-header"><a href="#safety">Safety</a></h1>
<p>The CUDA context management API does not fit easily into Rust’s safety guarantees.</p>
<p>The thread-local stack (as well as the fact that any context can be on the stack for any number
of threads) means there is no clear owner for a CUDA context, but it still has to be cleaned up.
Also, the fact that a context can be current to multiple threads at once means that there can be
multiple implicit references to a context which are not controlled by Rust.</p>
<p>RustaCUDA handles ownership by providing an owning <a href="struct.Context.html"><code>Context</code></a> struct and
a non-owning <a href="struct.UnownedContext.html"><code>UnownedContext</code></a>. When the <code>Context</code> is dropped, the
backing context is destroyed. The context could be current on other threads, though. In this
case, the context is still destroyed, and attempts to access the context on other threads will
fail with an error. This is (mostly) safe, if a bit inconvenient. It’s only mostly safe because
other threads could be accessing that context while the destructor is running on this thread,
which could result in undefined behavior.</p>
<p>In short, Rust’s thread-safety guarantees cannot fully protect use of the context management
functions. The programmer must ensure that no other OS threads are using the <code>Context</code> when it
is dropped.</p>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1>
<p>For most commmon uses (one device, one OS thread) it should suffice to create a single context:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">rustacuda::device::Device</span>;
<span class="kw">use</span> <span class="ident">rustacuda::context</span>::{<span class="ident">Context</span>, <span class="ident">ContextFlags</span>};

<span class="ident">rustacuda::init</span>(<span class="ident">rustacuda::CudaFlags::empty</span>())<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">device</span> <span class="op">=</span> <span class="ident">Device::get_device</span>(<span class="number">0</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">context</span> <span class="op">=</span> <span class="ident">Context::create_and_push</span>(<span class="ident">ContextFlags::MAP_HOST</span> <span class="op">|</span> <span class="ident">ContextFlags::SCHED_AUTO</span>, <span class="ident">device</span>)<span class="question-mark">?</span>;
<span class="comment">// call RustaCUDA functions which use the context</span>

<span class="comment">// The context will be destroyed when dropped or it falls out of scope.</span>
<span class="ident">drop</span>(<span class="ident">context</span>);</code></pre></div>
<p>If you have multiple OS threads that each submit work to the same device, you can get a handle
to the single context and pass it to each thread.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// As before</span>
<span class="kw">let</span> <span class="ident">context</span> <span class="op">=</span>
    <span class="ident">Context::create_and_push</span>(<span class="ident">ContextFlags::MAP_HOST</span> <span class="op">|</span> <span class="ident">ContextFlags::SCHED_AUTO</span>, <span class="ident">device</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">join_handles</span> <span class="op">=</span> <span class="macro">vec!</span>[];

<span class="kw">for</span> <span class="kw">_</span> <span class="kw">in</span> <span class="number">0</span>..<span class="number">4</span> {
    <span class="kw">let</span> <span class="ident">unowned</span> <span class="op">=</span> <span class="ident">context</span>.<span class="ident">get_unowned</span>();
    <span class="kw">let</span> <span class="ident">join_handle</span> <span class="op">=</span> <span class="ident">std::thread::spawn</span>(<span class="kw">move</span> <span class="op">|</span><span class="op">|</span> {
        <span class="ident">CurrentContext::set_current</span>(<span class="kw-2">&amp;</span><span class="ident">unowned</span>).<span class="ident">unwrap</span>();
        <span class="comment">// Call RustaCUDA functions which use the context</span>
    });
    <span class="ident">join_handles</span>.<span class="ident">push</span>(<span class="ident">join_handle</span>);
}
<span class="comment">// We must ensure that the other threads are not using the context when it&#39;s destroyed.</span>
<span class="kw">for</span> <span class="ident">handle</span> <span class="kw">in</span> <span class="ident">join_handles</span> {
    <span class="ident">handle</span>.<span class="ident">join</span>().<span class="ident">unwrap</span>();
}
<span class="comment">// Now it&#39;s safe to drop the context.</span>
<span class="ident">drop</span>(<span class="ident">context</span>);</code></pre></div>
<p>If you have multiple devices, each device needs its own context.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// Create and pop contexts for each device</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">contexts</span> <span class="op">=</span> <span class="macro">vec!</span>[];
<span class="kw">for</span> <span class="ident">device</span> <span class="kw">in</span> <span class="ident">Device::devices</span>()<span class="question-mark">?</span> {
    <span class="kw">let</span> <span class="ident">device</span> <span class="op">=</span> <span class="ident">device</span><span class="question-mark">?</span>;
    <span class="kw">let</span> <span class="ident">ctx</span> <span class="op">=</span>
        <span class="ident">Context::create_and_push</span>(<span class="ident">ContextFlags::MAP_HOST</span> <span class="op">|</span> <span class="ident">ContextFlags::SCHED_AUTO</span>, <span class="ident">device</span>)<span class="question-mark">?</span>;
    <span class="ident">ContextStack::pop</span>()<span class="question-mark">?</span>;
    <span class="ident">contexts</span>.<span class="ident">push</span>(<span class="ident">ctx</span>);
}
<span class="ident">CurrentContext::set_current</span>(<span class="kw-2">&amp;</span><span class="ident">contexts</span>[<span class="number">0</span>])<span class="question-mark">?</span>;

<span class="comment">// Call RustaCUDA functions which will use the context</span>
</code></pre></div>
</div></details><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="struct" href="struct.Context.html" title="rustacuda::context::Context struct">Context</a></div><div class="item-right docblock-short"><p>Owned handle to a CUDA context.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.ContextFlags.html" title="rustacuda::context::ContextFlags struct">ContextFlags</a></div><div class="item-right docblock-short"><p>Bit flags for initializing the CUDA context.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.ContextStack.html" title="rustacuda::context::ContextStack struct">ContextStack</a></div><div class="item-right docblock-short"><p>Type used to represent the thread-local context stack.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.CurrentContext.html" title="rustacuda::context::CurrentContext struct">CurrentContext</a></div><div class="item-right docblock-short"><p>Type representing the top context in the thread-local stack.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.StreamPriorityRange.html" title="rustacuda::context::StreamPriorityRange struct">StreamPriorityRange</a></div><div class="item-right docblock-short"><p>Struct representing a range of stream priorities.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.UnownedContext.html" title="rustacuda::context::UnownedContext struct">UnownedContext</a></div><div class="item-right docblock-short"><p>Non-owning handle to a CUDA context.</p>
</div></div><h2 id="enums" class="section-header"><a href="#enums">Enums</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="enum" href="enum.CacheConfig.html" title="rustacuda::context::CacheConfig enum">CacheConfig</a></div><div class="item-right docblock-short"><p>This enumeration represents configuration settings for devices which share hardware resources
between L1 cache and shared memory.</p>
</div><div class="item-left module-item"><a class="enum" href="enum.ResourceLimit.html" title="rustacuda::context::ResourceLimit enum">ResourceLimit</a></div><div class="item-right docblock-short"><p>This enumeration represents the limited resources which can be accessed through
<a href="struct.CurrentContext.html#method.get_resource_limit">CurrentContext::get_resource_limit</a> and
<a href="struct.CurrentContext.html#method.set_resource_limit">CurrentContext::set_resource_limit</a>.</p>
</div><div class="item-left module-item"><a class="enum" href="enum.SharedMemoryConfig.html" title="rustacuda::context::SharedMemoryConfig enum">SharedMemoryConfig</a></div><div class="item-right docblock-short"><p>This enumeration represents the options for configuring the shared memory bank size.</p>
</div></div><h2 id="traits" class="section-header"><a href="#traits">Traits</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="trait" href="trait.ContextHandle.html" title="rustacuda::context::ContextHandle trait">ContextHandle</a></div><div class="item-right docblock-short"><p>Sealed trait for <code>Context</code> and <code>UnownedContext</code>. Not intended for use outside of RustaCUDA.</p>
</div></div></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../../" data-current-crate="rustacuda" data-search-index-js="../../search-index.js" data-search-js="../../search.js"></div>
    <script src="../../main.js"></script>
</body></html>