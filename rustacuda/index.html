<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="This crate provides a safe, user-friendly wrapper around the CUDA Driver API."><meta name="keywords" content="rust, rustlang, rust-lang, rustacuda"><title>rustacuda - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings" ></script><script src="../storage.js"></script><script src="../crates.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../rustacuda/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><h2 class="location">Crate rustacuda</h2><div class="block version"><div class="narrow-helper"></div><p>Version 0.1.3</p></div><div class="sidebar-elems"><a id="all-types" href="all.html"><p>See all rustacuda's items</p></a><div class="block items"><ul><li><a href="#modules">Modules</a></li><li><a href="#macros">Macros</a></li><li><a href="#structs">Structs</a></li><li><a href="#functions">Functions</a></li></ul></div><div id="sidebar-vars" data-name="rustacuda" data-ty="mod" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../wheel.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Crate <a class="mod" href="#">rustacuda</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/rustacuda/lib.rs.html#1-278" title="goto source code">[src]</a></span></h1><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>This crate provides a safe, user-friendly wrapper around the CUDA Driver API.</p>
<h1 id="cuda-terminology" class="section-header"><a href="#cuda-terminology">CUDA Terminology</a></h1><h2 id="devices-and-hosts" class="section-header"><a href="#devices-and-hosts">Devices and Hosts</a></h2>
<p>This crate and its documentation uses the terms “device” and “host” frequently, so it’s worth
explaining them in more detail.</p>
<p><strong>Device</strong> refers to a CUDA-capable GPU or similar device and its associated external memory space.</p>
<p><strong>Host</strong> is the CPU and its associated memory space. Data must be transferred from host memory
to device memory before the device can use the data for computations, and the results must then
be transferred back to host memory in order to use the results on the CPU, such as in your Rust
code.</p>
<h2 id="contexts-modules-streams-and-functions" class="section-header"><a href="#contexts-modules-streams-and-functions">Contexts, Modules, Streams and Functions</a></h2>
<p><strong>Context</strong> is akin to a process on the host — it contains all of the state for working
with a device, all memory allocations, etc. Each context is associated with a single device.</p>
<p><strong>Module</strong> is similar to a shared-object library — it is a piece of compiled code which exports
functions and global values. Functions can be loaded from modules and launched on a device as
one might load a function from a shared-object file and call it. Functions are also known as
kernels, both of which are short terms for global kernel function, and these terms will be used
interchangeably.</p>
<p><strong>Stream</strong> is akin to a thread — asynchronous work such as kernel execution can be queued into a
stream. Work within a single stream will execute sequentially in the order that it was
submitted, and may interleave with work from other streams.</p>
<h2 id="grids-blocks-threads-and-shared-memory" class="section-header"><a href="#grids-blocks-threads-and-shared-memory">Grids, Blocks, Threads and Shared Memory</a></h2>
<p>CUDA devices contain multiple separate processors, known as multiprocessors or MPs. Each
multiprocessor is capable of executing large number of <strong>threads</strong> simultaneously, grouped
into thread blocks, or <strong>blocks</strong> in short. Each thread block executes on a single
multiprocessor and shares an area of fast on-chip memory known as <strong>shared memory</strong>.
Accesses to shared memory on the physical multiprocessor are typically more than 10 times
faster than accesses to device global memory, which is accessible across all thread blocks.
Thread blocks can be one-, two-, or three-dimensional, which is helpful when working with
multi-dimensional data such as images.</p>
<p>Thread blocks are launched in <strong>grids</strong>, which also can be one-, two-, or three-dimensional.
The total number of threads launched by a kernel launch will be the product of grid size
multiplied by thread block size.</p>
<p>For achieving high computation throughput, it is important to ensure that the grid size
is large enough, so that optimal number of multiprocessors are utilized to complete the
work. On the other hand, if the number of threads in each thread block gets too small,
each multiprocessor may be under-utilized, or kernels using shared memory may not be
able to make effective use of the fast shared memory.</p>
<h1 id="usage" class="section-header"><a href="#usage">Usage</a></h1>
<p>Before using RustaCUDA, you must install the CUDA development libraries for your system. Version
8.0 or newer is required. You must also have a CUDA-capable GPU installed with the appropriate
drivers.</p>
<p>Add the following to your <code>Cargo.toml</code>:</p>
<div class="example-wrap"><pre class="language-text"><code>[dependencies]
rustacuda = &quot;0.1&quot;
rustacuda_core = &quot;0.1&quot;</code></pre></div>
<p>And this to your crate root:</p>
<div class="example-wrap"><pre class="language-text"><code>#[macro_use]
extern crate rustacuda;
extern crate rustacuda_core;</code></pre></div>
<p>Finally, set the CUDA library path environment variable to the location of your CUDA libraries.</p>
<h4 id="ubuntu" class="section-header"><a href="#ubuntu">Ubuntu</a></h4><div class="example-wrap"><pre class="language-shell"><code>export LIBRARY_PATH=/usr/local/cuda/lib64</code></pre></div><h4 id="windows" class="section-header"><a href="#windows">Windows</a></h4><div class="example-wrap"><pre class="language-shell"><code>export CUDA_LIBRARY_PATH=&quot;C:\Program Files\NVIDIA GPU Computing Toolkit\CUDA\v11.3\lib\x64&quot;</code></pre></div><h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1><h2 id="adding-two-numbers-on-the-device" class="section-header"><a href="#adding-two-numbers-on-the-device">Adding two numbers on the device</a></h2>
<p>First, download the <code>resources/add.ptx</code> file from the RustaCUDA repository and place it in
the resources directory for your application.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="attribute">#[<span class="ident">macro_use</span>]</span>
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">rustacuda</span>;
<span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">rustacuda_core</span>;

<span class="kw">use</span> <span class="ident">rustacuda::prelude</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">rustacuda::memory::DeviceBox</span>;
<span class="kw">use</span> <span class="ident">std::error::Error</span>;
<span class="kw">use</span> <span class="ident">std::ffi::CString</span>;

<span class="kw">fn</span> <span class="ident">main</span>() <span class="op">-</span><span class="op">&gt;</span> <span class="prelude-ty">Result</span><span class="op">&lt;</span>(), <span class="ident">Box</span><span class="op">&lt;</span><span class="kw">dyn</span> <span class="ident">Error</span><span class="op">&gt;</span><span class="op">&gt;</span> {
    <span class="comment">// Initialize the CUDA API</span>
    <span class="ident">rustacuda::init</span>(<span class="ident">CudaFlags::empty</span>())<span class="question-mark">?</span>;

    <span class="comment">// Get the first device</span>
    <span class="kw">let</span> <span class="ident">device</span> <span class="op">=</span> <span class="ident">Device::get_device</span>(<span class="number">0</span>)<span class="question-mark">?</span>;

    <span class="comment">// Create a context associated to this device</span>
    <span class="kw">let</span> <span class="ident">context</span> <span class="op">=</span> <span class="ident">Context::create_and_push</span>(
        <span class="ident">ContextFlags::MAP_HOST</span> <span class="op">|</span> <span class="ident">ContextFlags::SCHED_AUTO</span>, <span class="ident">device</span>)<span class="question-mark">?</span>;

    <span class="comment">// Load the module containing the global kernel function we want to call</span>
    <span class="kw">let</span> <span class="ident">module_data</span> <span class="op">=</span> <span class="ident">CString::new</span>(<span class="macro">include_str!</span>(<span class="string">&quot;../resources/add.ptx&quot;</span>))<span class="question-mark">?</span>;
    <span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::load_from_string</span>(<span class="kw-2">&amp;</span><span class="ident">module_data</span>)<span class="question-mark">?</span>;

    <span class="comment">// Create a stream to submit work to</span>
    <span class="kw">let</span> <span class="ident">stream</span> <span class="op">=</span> <span class="ident">Stream::new</span>(<span class="ident">StreamFlags::NON_BLOCKING</span>, <span class="prelude-val">None</span>)<span class="question-mark">?</span>;

    <span class="comment">// Allocate space on the device and copy numbers to it.</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">x</span> <span class="op">=</span> <span class="ident">DeviceBox::new</span>(<span class="kw-2">&amp;</span><span class="number">10.0f32</span>)<span class="question-mark">?</span>;
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">y</span> <span class="op">=</span> <span class="ident">DeviceBox::new</span>(<span class="kw-2">&amp;</span><span class="number">20.0f32</span>)<span class="question-mark">?</span>;
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">result</span> <span class="op">=</span> <span class="ident">DeviceBox::new</span>(<span class="kw-2">&amp;</span><span class="number">0.0f32</span>)<span class="question-mark">?</span>;

    <span class="comment">// Launching kernels is unsafe since Rust can&#39;t enforce safety.</span>
    <span class="comment">// Think of kernel launches as a foreign-function call. In this case,</span>
    <span class="comment">// it is — this kernel is written in CUDA C, compiled to PTX, and then</span>
    <span class="comment">// loaded and executed on the CUDA device.</span>
    <span class="kw">unsafe</span> {
        <span class="comment">// Launch the `add` global kernel function with one block containing one thread</span>
        <span class="comment">// without shared memory on the given stream.</span>
        <span class="macro">launch!</span>(<span class="ident">module</span>.<span class="ident">add</span><span class="op">&lt;</span><span class="op">&lt;</span><span class="op">&lt;</span><span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="ident">stream</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="op">&gt;</span>(
            <span class="ident">x</span>.<span class="ident">as_device_ptr</span>(),
            <span class="ident">y</span>.<span class="ident">as_device_ptr</span>(),
            <span class="ident">result</span>.<span class="ident">as_device_ptr</span>(),
            <span class="number">1u32</span> <span class="comment">// Number of values in device buffers</span>
        ))<span class="question-mark">?</span>;
    }

    <span class="comment">// Kernel launches are always asynchronous, so wait for the stream</span>
    <span class="comment">// to complete queued kernel launches, as well as any other tasks</span>
    <span class="comment">// submitted to the stream.</span>
    <span class="ident">stream</span>.<span class="ident">synchronize</span>()<span class="question-mark">?</span>;

    <span class="comment">// Copy the result back to the host</span>
    <span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">result_host</span> <span class="op">=</span> <span class="number">0.0f32</span>;
    <span class="ident">result</span>.<span class="ident">copy_to</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">result_host</span>)<span class="question-mark">?</span>;

    <span class="macro">println!</span>(<span class="string">&quot;Sum is {}&quot;</span>, <span class="ident">result_host</span>);
    <span class="macro">assert_eq!</span>(<span class="number">30.0f32</span>, <span class="ident">result_host</span>);

    <span class="prelude-val">Ok</span>(())
}</code></pre></div>
</div></details><h2 id="modules" class="section-header"><a href="#modules">Modules</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="mod" href="context/index.html" title="rustacuda::context mod">context</a></div><div class="item-right docblock-short"><p>CUDA context management</p>
</div><div class="item-left module-item"><a class="mod" href="device/index.html" title="rustacuda::device mod">device</a></div><div class="item-right docblock-short"><p>Functions and types for enumerating CUDA devices and retrieving information about them.</p>
</div><div class="item-left module-item"><a class="mod" href="error/index.html" title="rustacuda::error mod">error</a></div><div class="item-right docblock-short"><p>Types for error handling</p>
</div><div class="item-left module-item"><a class="mod" href="event/index.html" title="rustacuda::event mod">event</a></div><div class="item-right docblock-short"><p>Events can be used to track status and dependencies, as well as to measure
the duration of work submitted to a CUDA stream.</p>
</div><div class="item-left module-item"><a class="mod" href="function/index.html" title="rustacuda::function mod">function</a></div><div class="item-right docblock-short"><p>Functions and types for working with CUDA kernels.</p>
</div><div class="item-left module-item"><a class="mod" href="memory/index.html" title="rustacuda::memory mod">memory</a></div><div class="item-right docblock-short"><p>Access to CUDA’s memory allocation and transfer functions.</p>
</div><div class="item-left module-item"><a class="mod" href="module/index.html" title="rustacuda::module mod">module</a></div><div class="item-right docblock-short"><p>Functions and types for working with CUDA modules.</p>
</div><div class="item-left module-item"><a class="mod" href="prelude/index.html" title="rustacuda::prelude mod">prelude</a></div><div class="item-right docblock-short"><p>This module re-exports a number of commonly-used types for working with RustaCUDA.</p>
</div><div class="item-left module-item"><a class="mod" href="stream/index.html" title="rustacuda::stream mod">stream</a></div><div class="item-right docblock-short"><p>Streams of work for the device to perform.</p>
</div></div><h2 id="macros" class="section-header"><a href="#macros">Macros</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="macro" href="macro.launch.html" title="rustacuda::launch macro">launch</a></div><div class="item-right docblock-short"><p>Launch a global kernel function asynchronously.</p>
</div></div><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="struct" href="struct.CudaApiVersion.html" title="rustacuda::CudaApiVersion struct">CudaApiVersion</a></div><div class="item-right docblock-short"><p>Struct representing the CUDA API version number.</p>
</div><div class="item-left module-item"><a class="struct" href="struct.CudaFlags.html" title="rustacuda::CudaFlags struct">CudaFlags</a></div><div class="item-right docblock-short"><p>Bit flags for initializing the CUDA driver. Currently, no flags are defined,
so <code>CudaFlags::empty()</code> is the only valid value.</p>
</div></div><h2 id="functions" class="section-header"><a href="#functions">Functions</a></h2>
<div class="item-table"><div class="item-left module-item"><a class="fn" href="fn.init.html" title="rustacuda::init fn">init</a></div><div class="item-right docblock-short"><p>Initialize the CUDA Driver API.</p>
</div><div class="item-left module-item"><a class="fn" href="fn.quick_init.html" title="rustacuda::quick_init fn">quick_init</a></div><div class="item-right docblock-short"><p>Shortcut for initializing the CUDA Driver API and creating a CUDA context with default settings
for the first device.</p>
</div></div></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../" data-current-crate="rustacuda" data-search-index-js="../search-index.js" data-search-js="../search.js"></div>
    <script src="../main.js"></script>
</body></html>