<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Launch a global kernel function asynchronously."><meta name="keywords" content="rust, rustlang, rust-lang, launch"><title>launch in rustacuda - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings" ></script><script src="../storage.js"></script><script src="../crates.js"></script><noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc macro"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../rustacuda/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><div class="sidebar-elems"><h2 class="location">Other items in<br><a href="index.html">rustacuda</a></h2><div id="sidebar-vars" data-name="launch" data-ty="macro" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" disabled autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../wheel.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Macro <a href="index.html">rustacuda</a>::<wbr><a class="macro" href="#">launch</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/rustacuda/function.rs.html#445-467" title="goto source code">[src]</a></span></h1><div class="docblock type-decl"><div class="example-wrap"><pre class="rust macro"><code><span class="macro">macro_rules!</span> <span class="ident">launch</span> {
    (<span class="macro-nonterminal">$</span><span class="macro-nonterminal">module</span> : <span class="ident">ident</span>.<span class="macro-nonterminal">$</span><span class="macro-nonterminal">function</span> : <span class="ident">ident</span> <span class="op">&lt;</span><span class="op">&lt;</span> <span class="op">&lt;</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">grid</span> : <span class="ident">expr</span>, <span class="macro-nonterminal">$</span><span class="macro-nonterminal">block</span> : <span class="ident">expr</span>, <span class="macro-nonterminal">$</span><span class="macro-nonterminal">shared</span> :
 <span class="ident">expr</span>, <span class="macro-nonterminal">$</span><span class="macro-nonterminal">stream</span> : <span class="ident">ident</span> <span class="op">&gt;</span><span class="op">&gt;</span> <span class="op">&gt;</span> ($(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">arg</span> : <span class="ident">expr</span>), <span class="kw-2">*</span>)) <span class="op">=</span><span class="op">&gt;</span> { ... };
    (<span class="macro-nonterminal">$</span><span class="macro-nonterminal">function</span> : <span class="ident">ident</span> <span class="op">&lt;</span><span class="op">&lt;</span> <span class="op">&lt;</span> <span class="macro-nonterminal">$</span><span class="macro-nonterminal">grid</span> : <span class="ident">expr</span>, <span class="macro-nonterminal">$</span><span class="macro-nonterminal">block</span> : <span class="ident">expr</span>, <span class="macro-nonterminal">$</span><span class="macro-nonterminal">shared</span> : <span class="ident">expr</span>, <span class="macro-nonterminal">$</span><span class="macro-nonterminal">stream</span> :
 <span class="ident">ident</span> <span class="op">&gt;</span><span class="op">&gt;</span> <span class="op">&gt;</span> ($(<span class="macro-nonterminal">$</span><span class="macro-nonterminal">arg</span> : <span class="ident">expr</span>), <span class="kw-2">*</span>)) <span class="op">=</span><span class="op">&gt;</span> { ... };
}</code></pre></div>
</div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Launch a global kernel function asynchronously.</p>
<h1 id="syntax" class="section-header"><a href="#syntax">Syntax</a></h1>
<p>The format of this macro is designed to resemble the triple-chevron syntax used to launch
kernels in CUDA C. There are two forms available:</p>

<div class='information'><div class='tooltip ignore'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore"><code><span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="macro">launch!</span>(<span class="ident">module</span>.<span class="ident">function_name</span><span class="op">&lt;</span><span class="op">&lt;</span><span class="op">&lt;</span><span class="ident">grid</span>, <span class="ident">block</span>, <span class="ident">shared_memory_size</span>, <span class="ident">stream</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="op">&gt;</span>(<span class="ident">parameter1</span>, <span class="ident">parameter2</span>...));</code></pre></div>
<p>This will load a kernel called <code>function_name</code> from the module <code>module</code> and launch it with
the given grid, block and shared memory sizes on the given stream. Unlike in CUDA C, the shared memory size and
stream parameters are not optional. The shared memory size is a number of bytes per thread for
dynamic shared memory (Note that this uses <code>extern __shared__ int x[]</code> in CUDA C, not the
fixed-length arrays created by <code>__shared__ int x[64]</code>. This will usually be zero.).
<code>stream</code> must be the name of a <a href="stream/struct.Stream.html"><code>Stream</code></a> value.
<code>grid</code> can be any value which implements <a href="function/struct.GridSize.html"><code>Into&lt;GridSize&gt;</code></a> (such as
<code>u32</code> values, tuples of up to three <code>u32</code> values, and GridSize structures) and likewise <code>block</code>
can be any value that implements <a href="function/struct.BlockSize.html"><code>Into&lt;BlockSize&gt;</code></a>.</p>
<p>NOTE: due to some limitations of Rust’s macro system, <code>module</code> and <code>stream</code> must be local
variable names. Paths or function calls will not work.</p>
<p>The second form is similar:</p>

<div class='information'><div class='tooltip ignore'>ⓘ</div></div><div class="example-wrap"><pre class="rust rust-example-rendered ignore"><code><span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="macro">launch!</span>(<span class="ident">function</span><span class="op">&lt;</span><span class="op">&lt;</span><span class="op">&lt;</span><span class="ident">grid</span>, <span class="ident">block</span>, <span class="ident">shared_memory_size</span>, <span class="ident">stream</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="op">&gt;</span>(<span class="ident">parameter1</span>, <span class="ident">parameter2</span>...));</code></pre></div>
<p>In this variant, the <code>function</code> parameter must be a variable. Use this form to avoid looking up
the kernel function for each call.</p>
<h1 id="safety" class="section-header"><a href="#safety">Safety</a></h1>
<p>Launching kernels must be done in an <code>unsafe</code> block. Calling a kernel is similar to calling a
foreign-language function, as the kernel itself could be written in C or unsafe Rust. The kernel
must accept the same number and type of parameters that are passed to the <code>launch!</code> macro. The
kernel must not write invalid data (for example, invalid enums) into areas of memory that can
be copied back to the host. The programmer must ensure that the host does not access device or
unified memory that the kernel could write to until after calling <code>stream.synchronize()</code>.</p>
<h1 id="examples" class="section-header"><a href="#examples">Examples</a></h1>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use</span> <span class="ident">rustacuda::memory</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">rustacuda::module::Module</span>;
<span class="kw">use</span> <span class="ident">rustacuda::stream</span>::<span class="kw-2">*</span>;
<span class="kw">use</span> <span class="ident">std::ffi::CString</span>;


<span class="comment">// Set up the context, load the module, and create a stream to run kernels in.</span>
<span class="kw">let</span> <span class="ident">_ctx</span> <span class="op">=</span> <span class="ident">rustacuda::quick_init</span>()<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">ptx</span> <span class="op">=</span> <span class="ident">CString::new</span>(<span class="macro">include_str!</span>(<span class="string">&quot;../resources/add.ptx&quot;</span>))<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">module</span> <span class="op">=</span> <span class="ident">Module::load_from_string</span>(<span class="kw-2">&amp;</span><span class="ident">ptx</span>)<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="ident">stream</span> <span class="op">=</span> <span class="ident">Stream::new</span>(<span class="ident">StreamFlags::NON_BLOCKING</span>, <span class="prelude-val">None</span>)<span class="question-mark">?</span>;

<span class="doccomment">/// Number of values in device buffers</span>
<span class="kw">const</span> <span class="ident">N</span>: <span class="ident">usize</span> <span class="op">=</span> <span class="number">10</span>;

<span class="comment">// Create buffers for data</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">in_x</span> <span class="op">=</span> <span class="ident">DeviceBuffer::from_slice</span>(<span class="kw-2">&amp;</span>[<span class="number">1.0f32</span>; <span class="ident">N</span>])<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">in_y</span> <span class="op">=</span> <span class="ident">DeviceBuffer::from_slice</span>(<span class="kw-2">&amp;</span>[<span class="number">2.0f32</span>; <span class="ident">N</span>])<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">out_1</span> <span class="op">=</span> <span class="ident">DeviceBuffer::from_slice</span>(<span class="kw-2">&amp;</span>[<span class="number">0.0f32</span>; <span class="ident">N</span>])<span class="question-mark">?</span>;
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">out_2</span> <span class="op">=</span> <span class="ident">DeviceBuffer::from_slice</span>(<span class="kw-2">&amp;</span>[<span class="number">0.0f32</span>; <span class="ident">N</span>])<span class="question-mark">?</span>;

<span class="comment">// This kernel adds each element in `in_x` and `in_y` and writes the result</span>
<span class="comment">// into `out` at corresponding index.</span>
<span class="kw">unsafe</span> {
    <span class="comment">// Launch the kernel with one block of one thread, without shared memory on `stream`.</span>
    <span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="macro">launch!</span>(<span class="ident">module</span>.<span class="ident">add</span><span class="op">&lt;</span><span class="op">&lt;</span><span class="op">&lt;</span><span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="ident">stream</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="op">&gt;</span>(
        <span class="ident">in_x</span>.<span class="ident">as_device_ptr</span>(),
        <span class="ident">in_y</span>.<span class="ident">as_device_ptr</span>(),
        <span class="ident">out_1</span>.<span class="ident">as_device_ptr</span>(),
        <span class="number">1u32</span>
    ));
    <span class="comment">// `launch!` returns an error in case anything went wrong with the launch</span>
    <span class="comment">// itself, but as kernel launches are asynchronous the errors caused</span>
    <span class="comment">// by the kernel (eg. invalid memory access) will show up at next</span>
    <span class="comment">// `Stream::synchronize()` or one of the subsequent CUDA API calls.</span>
    <span class="ident">result</span><span class="question-mark">?</span>;

    <span class="comment">// Launch the kernel again using the `function` form:</span>
    <span class="kw">let</span> <span class="ident">function_name</span> <span class="op">=</span> <span class="ident">CString::new</span>(<span class="string">&quot;add&quot;</span>)<span class="question-mark">?</span>;
    <span class="kw">let</span> <span class="ident">sum</span> <span class="op">=</span> <span class="ident">module</span>.<span class="ident">get_function</span>(<span class="kw-2">&amp;</span><span class="ident">function_name</span>)<span class="question-mark">?</span>;
    <span class="comment">// Launch with 1x1x1 (1) blocks of 10x1x1 (10) threads, to show</span>
    <span class="comment">// that you can use tuples to configure grid and block size.</span>
    <span class="kw">let</span> <span class="ident">result</span> <span class="op">=</span> <span class="macro">launch!</span>(<span class="ident">sum</span><span class="op">&lt;</span><span class="op">&lt;</span><span class="op">&lt;</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>), (<span class="number">10</span>, <span class="number">1</span>, <span class="number">1</span>), <span class="number">0</span>, <span class="ident">stream</span><span class="op">&gt;</span><span class="op">&gt;</span><span class="op">&gt;</span>(
        <span class="ident">in_x</span>.<span class="ident">as_device_ptr</span>(),
        <span class="ident">in_y</span>.<span class="ident">as_device_ptr</span>(),
        <span class="ident">out_2</span>.<span class="ident">as_device_ptr</span>(),
        <span class="ident">N</span> <span class="kw">as</span> <span class="ident">u32</span>
    ));
    <span class="ident">result</span><span class="question-mark">?</span>;
}

<span class="comment">// Kernel launches are always asynchronous, so wait for the stream</span>
<span class="comment">// to complete queued kernel launches, as well as other queued work.</span>
<span class="ident">stream</span>.<span class="ident">synchronize</span>()<span class="question-mark">?</span>;

<span class="comment">// Copy the results back to host memory</span>
<span class="kw">let</span> <span class="kw-2">mut</span> <span class="ident">out_host</span> <span class="op">=</span> [<span class="number">0.0f32</span>; <span class="number">11</span>];
<span class="ident">out_1</span>[<span class="number">0</span>..<span class="number">1</span>].<span class="ident">copy_to</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">out_host</span>[<span class="number">0</span>..<span class="number">1</span>])<span class="question-mark">?</span>;
<span class="ident">out_2</span>.<span class="ident">copy_to</span>(<span class="kw-2">&amp;</span><span class="kw-2">mut</span> <span class="ident">out_host</span>[<span class="number">1</span>..<span class="number">11</span>])<span class="question-mark">?</span>;

<span class="kw">for</span> <span class="ident">x</span> <span class="kw">in</span> <span class="ident">out_host</span>.<span class="ident">iter</span>() {
    <span class="macro">assert_eq!</span>(<span class="number">3.0</span>, <span class="kw-2">*</span><span class="ident">x</span>);
}</code></pre></div>
</div></details></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../" data-current-crate="rustacuda" data-search-index-js="../search-index.js" data-search-js="../search.js"></div>
    <script src="../main.js"></script>
</body></html>